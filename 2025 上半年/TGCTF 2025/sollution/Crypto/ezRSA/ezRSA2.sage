from Crypto.Util.number import *
import gmpy2

def part_roots(n, c, e, p):
    # 将e约简到可逆，g为余下的因数
    def div_e(e, p):
        g = GCD(e, (p - 1))
        while GCD(e, (p - 1)) != 1:
            e //= GCD(e, (p - 1))
            g *= GCD(e, (p - 1))
        return e, g
    
    # 约简e，便于开根
    e, g = div_e(e, p)
    d = inverse(e, p - 1)
    M = pow(c, d, p)
    
    # 在有限域内开根
    R.<x> = Zmod(p)[]
    f = x ^ g - M
    return [int(i[0]) for i in f.monic().roots()]

n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579
c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401

p = 12424840247075830662687097292458444573014198016321428995092662043898159667123240573630892907827505266982898641483333170032514244713840745287869771915696311
q = 12602471198163266643743702664647336358595911975665358584258749238146841559843060594842063473155049870396568542257767865369797827796765830093256146584311989

e = "💯"
e = bytes_to_long(e.encode())

res1 = part_roots(n, c, e, p)
res2 = part_roots(n, c, e, q)

for i in res1:
    for j in res2:
        m = crt([i, j], [p, q])
#         print(long_to_bytes(m))
        try:
            print(long_to_bytes(m).decode())
        except:
            pass
