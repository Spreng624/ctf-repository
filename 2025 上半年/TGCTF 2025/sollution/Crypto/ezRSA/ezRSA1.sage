from Crypto.Util.number import *

n = 156583691355552921614631145152732482393176197132995684056861057354110068341462353935267384379058316405283253737394317838367413343764593681931500132616527754658531492837010737718142600521325345568856010357221012237243808583944390972551218281979735678709596942275013178851539514928075449007568871314257800372579
c = 47047259652272336203165844654641527951135794808396961300275905227499051240355966018762052339199047708940870407974724853429554168419302817757183570945811400049095628907115694231183403596602759249583523605700220530849961163557032168735648835975899744556626132330921576826526953069435718888223260480397802737401

bit = 288

for code_point in range(0x1F600, 0x1F64F + 1):
    emoji = chr(code_point)
    p0 = emoji + "ðŸ˜˜ðŸ˜¾ðŸ˜‚ðŸ˜‹ðŸ˜¶ðŸ˜¾ðŸ˜³ðŸ˜·"
    low_p = bytes_to_long(p0.encode())

    R.<x> = PolynomialRing(Zmod(n), implementation='NTL')
    f = x * 2^bit + low_p
    roots = f.monic().small_roots(X=2^224, beta=0.4)

    if roots:
        print("Found: ")
        p = int(roots[0] * 2^bit + low_p)
        q = n // p
        assert p * q == n
        print(f"p = {p}")
        print(f"q = {q}")
        break
else:
    print("Fail")
    
'''
Found: 
p = 12424840247075830662687097292458444573014198016321428995092662043898159667123240573630892907827505266982898641483333170032514244713840745287869771915696311
q = 12602471198163266643743702664647336358595911975665358584258749238146841559843060594842063473155049870396568542257767865369797827796765830093256146584311989
'''